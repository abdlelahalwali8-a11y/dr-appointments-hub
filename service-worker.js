const CACHE_NAME = 'dr-appointments-v1';\nconst RUNTIME_CACHE = 'dr-appointments-runtime';\nconst ASSETS_TO_CACHE = [\n  '/',\n  '/index.html',\n  '/manifest.json',\n  '/icons/icon-192x192.png',\n  '/icons/icon-512x512.png',\n];\n\n// Install event\nself.addEventListener('install', (event) => {\n  console.log('Service Worker installing...');\n  event.waitUntil(\n    caches.open(CACHE_NAME).then((cache) => {\n      console.log('Caching assets');\n      return cache.addAll(ASSETS_TO_CACHE);\n    })\n  );\n  self.skipWaiting();\n});\n\n// Activate event\nself.addEventListener('activate', (event) => {\n  console.log('Service Worker activating...');\n  event.waitUntil(\n    caches.keys().then((cacheNames) => {\n      return Promise.all(\n        cacheNames.map((cacheName) => {\n          if (cacheName !== CACHE_NAME && cacheName !== RUNTIME_CACHE) {\n            console.log('Deleting old cache:', cacheName);\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n  self.clients.claim();\n});\n\n// Fetch event\nself.addEventListener('fetch', (event) => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n  // Skip cross-origin requests\n  if (url.origin !== location.origin) {\n    return;\n  }\n\n  // Handle API requests with network-first strategy\n  if (url.pathname.startsWith('/api/')) {\n    event.respondWith(\n      fetch(request)\n        .then((response) => {\n          // Clone the response\n          const clonedResponse = response.clone();\n          // Cache the response\n          caches.open(RUNTIME_CACHE).then((cache) => {\n            cache.put(request, clonedResponse);\n          });\n          return response;\n        })\n        .catch(() => {\n          // Return cached response if network fails\n          return caches.match(request);\n        })\n    );\n    return;\n  }\n\n  // Handle static assets with cache-first strategy\n  event.respondWith(\n    caches.match(request).then((response) => {\n      if (response) {\n        return response;\n      }\n      return fetch(request).then((response) => {\n        // Don't cache non-successful responses\n        if (!response || response.status !== 200 || response.type === 'error') {\n          return response;\n        }\n        // Clone the response\n        const clonedResponse = response.clone();\n        // Cache the response\n        caches.open(RUNTIME_CACHE).then((cache) => {\n          cache.put(request, clonedResponse);\n        });\n        return response;\n      });\n    })\n  );\n});\n\n// Handle push notifications\nself.addEventListener('push', (event) => {\n  console.log('Push notification received:', event);\n\n  let notificationData = {\n    title: 'إشعار من نظام المواعيد الطبية',\n    body: 'لديك إشعار جديد',\n    icon: '/icons/icon-192x192.png',\n    badge: '/icons/icon-192x192.png',\n    tag: 'notification',\n    requireInteraction: false,\n  };\n\n  if (event.data) {\n    try {\n      notificationData = { ...notificationData, ...event.data.json() };\n    } catch (e) {\n      notificationData.body = event.data.text();\n    }\n  }\n\n  event.waitUntil(\n    self.registration.showNotification(notificationData.title, {\n      body: notificationData.body,\n      icon: notificationData.icon,\n      badge: notificationData.badge,\n      tag: notificationData.tag,\n      requireInteraction: notificationData.requireInteraction,\n      data: notificationData,\n      actions: [\n        {\n          action: 'open',\n          title: 'فتح',\n        },\n        {\n          action: 'close',\n          title: 'إغلاق',\n        },\n      ],\n    })\n  );\n});\n\n// Handle notification clicks\nself.addEventListener('notificationclick', (event) => {\n  console.log('Notification clicked:', event);\n  event.notification.close();\n\n  if (event.action === 'close') {\n    return;\n  }\n\n  const urlToOpen = event.notification.data?.url || '/';\n\n  event.waitUntil(\n    clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {\n      // Check if the app is already open\n      for (let i = 0; i < clientList.length; i++) {\n        const client = clientList[i];\n        if (client.url === urlToOpen && 'focus' in client) {\n          return client.focus();\n        }\n      }\n      // If not open, open a new window\n      if (clients.openWindow) {\n        return clients.openWindow(urlToOpen);\n      }\n    })\n  );\n});\n\n// Handle notification close\nself.addEventListener('notificationclose', (event) => {\n  console.log('Notification closed:', event);\n});\n\n// Handle background sync\nself.addEventListener('sync', (event) => {\n  console.log('Background sync event:', event.tag);\n\n  if (event.tag === 'sync-appointments') {\n    event.waitUntil(\n      fetch('/api/appointments/sync', { method: 'POST' })\n        .then((response) => {\n          if (!response.ok) {\n            throw new Error('Sync failed');\n          }\n          return response.json();\n        })\n        .catch((error) => {\n          console.error('Sync error:', error);\n          // Retry sync\n          return self.registration.sync.register('sync-appointments');\n        })\n    );\n  }\n});\n\n// Handle periodic background sync\nself.addEventListener('periodicsync', (event) => {\n  console.log('Periodic sync event:', event.tag);\n\n  if (event.tag === 'update-appointments') {\n    event.waitUntil(\n      fetch('/api/appointments/update', { method: 'POST' })\n        .then((response) => {\n          if (!response.ok) {\n            throw new Error('Update failed');\n          }\n          return response.json();\n        })\n        .catch((error) => {\n          console.error('Update error:', error);\n        })\n    );\n  }\n});\n
